/* EasyWay Game Engine
 * Copyright (C) 2006 Daniele Paggi.
 *  
 * Written by: 2006 Daniele Paggi<dshnt@hotmail.com>
 *   
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package org.easyway.effects.translator;

import org.easyway.system.Core;
import org.easyway.system.StaticRef;
import org.easyway.system.state.OpenGLState;
import org.lwjgl.opengl.GL11;

public class FadeZoomOut extends FadeOut {

	/**
	 * autogenerated serial version of class
	 */
	private static final long serialVersionUID = -8047130121624969617L;

	/**
	 * locations on witch will be done the zoom
	 */
	protected float x, y;

	protected float incx, decx, incy, decy;

	protected float currx, curry, currx2, curry2;

	protected boolean noX, noY;

	protected boolean changeAlpha;

	/**
	 * creates a new instance of FadeOut
	 * 
	 * @param time
	 *            indicates in how muck ms the fade out should be done
	 * @param x
	 *            the location to zoom
	 * @param y
	 *            the location to zoom
	 */
	public FadeZoomOut(int time, float x, float y) {
		this(time, x, y, true, 6);
	}

	/**
	 * creates a new instance of FadeOut
	 * 
	 * @param time
	 *            indicates in how muck ms the fade out should be done
	 * @param x
	 *            the location to zoom
	 * @param y
	 *            the location to zoom
	 * 
	 * @param idLayer
	 *            the drawing sheet.
	 */
	public FadeZoomOut(int time, float x, float y, int idLayer) {
		this(time, x, y, true, idLayer);
	}

	/**
	 * creates a new instance of FadeOut
	 * 
	 * @param time
	 *            indicates in how muck ms the fade out should be done
	 * @param x
	 *            the location to zoom
	 * @param y
	 *            the location to zoom
	 * 
	 * @param autoAddToLists
	 *            indicates if the objects auto add itself to the game engine's
	 *            lists.
	 */
	public FadeZoomOut(int time, float x, float y, boolean autoAddToLists) {
		this(time, x, y, autoAddToLists, 6);
	}

	/**
	 * creates a new instance of FadeOut
	 * 
	 * @param time
	 *            indicates in how muck ms the fade out should be done
	 * @param x
	 *            the location to zoom
	 * @param y
	 *            the location to zoom
	 * 
	 * @param autoADdToLists
	 *            indicates if the objects auto add itself to the game engine's
	 *            lists.
	 * @param idLayer
	 *            the drawing sheet.
	 */
	public FadeZoomOut(int time, float x, float y, boolean autoADdToLists,
			int idLayer) {
		super(time, autoADdToLists, idLayer);
		this.x = x;
		this.y = y;
		changeAlpha = true;
		generateIncDec();
	}

	public void generateIncDec() {
		decx = 1.0f - (incx = x / texture.getWidth());
		incy = 1.0f - (decy = y / texture.getHeight());
		currx = curry2 = 0.0f;
		currx2 = curry = 0.0f;
	}

	public void render() {
		// asssert noX == false || noY == false;
		assert !(noX && noY);
		float step = (float) ((float) Core.getInstance().getElaspedTime() / (float) time);
		if (changeAlpha) {
			alpha = alpha - step;
			if (alpha <= 0) {
				destroy();
				return;
			}
		}

		if (!noX) {
			currx += (incx * step);
			currx2 += (decx * step);
		}
		if (!noY) {
			curry += (decy * step);
			curry2 += (incy * step);
		}
		if (currx > texture.xEnd - currx2 || curry > texture.yEnd - curry2) {
			destroy();
			return;
		}
		texture.bind();

		// GL11.glLoadIdentity();
		// we can speed up these following 3 lines?
		OpenGLState.enableBlending();
		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);

		GL11.glColor4f(1, 1, 1, alpha);
		GL11.glBegin(GL11.GL_QUADS);
		GL11.glTexCoord2f(currx, texture.yEnd - curry);
		GL11.glVertex2f(0, 0);
		GL11.glTexCoord2f(texture.xEnd - currx2, texture.yEnd - curry);
		GL11.glVertex2f(StaticRef.getCamera().getWidth(), 0);
		GL11.glTexCoord2f(texture.xEnd - currx2, curry2);
		GL11.glVertex2f(StaticRef.getCamera().getWidth(), StaticRef.getCamera()
				.getHeight());
		GL11.glTexCoord2f(currx, curry2);
		GL11.glVertex2f(0, StaticRef.getCamera().getHeight());
		GL11.glEnd();

	}

	/**
	 * 
	 * @see #setOnlyYZoom()
	 * @see #setDefaultZoom()
	 */
	public void setOnlyXZoom() {
		noY = true;
		noX = false;
	}

	/**
	 * @see #setOnlyYZoom()
	 * @see #setDefaultZoom()
	 * 
	 */
	public void setOnlyYZoom() {
		noY = false;
		noX = true;
	}

	/**
	 * @see #setOnlyXZoom()
	 * @see #setOnlyYZoom()
	 * 
	 */
	public void setDefaultZoom() {
		noX = noY = true;
	}

	/**
	 * indicates if the effect should change the alpha component in the time or
	 * not.
	 * 
	 * @param chage
	 *            indicates if the effect should change the alpha component in
	 *            the time or not.
	 */
	public void changeAlpha(boolean change) {
		changeAlpha = change;
	}

}
